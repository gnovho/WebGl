// Hello MultiPoint 

// Vertex shader program
var VSHADER_SOURCE = 
	// 
	'attribute vec4 a_Position; \n' +
	'attribute vec4 a_Color; \n' +
	'uniform mat4 u_MvpMatrix;' +
	'varying vec4 v_Color; \n' +
	'void main(){ \n' +
	'	gl_Position = u_MvpMatrix * a_Position; \n' +
	'	v_Color = a_Color; \n' +
	'} \n';

// Fragment shader program 
var FSHADER_SOURCE = 	
	'precision mediump float; \n' +
	'varying vec4 v_Color; \n' +  
	'void main(){ \n' +
	'	gl_FragColor = v_Color; \n' +
	'} \n';

//main//main
function main(){
	
	//Retrieve <canvas>
	var canvas = document.getElementById('webgl', false);
	

	//Get the rendering context for Webgl
	var gl = getWebGLContext(canvas);
	if (!gl){
		console.log('Failed to get rendering');
		return;
	}

	
	//Initialize shader 
	if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)){
		console.log('Failed to initialize shader');
		return;
	}

	var u_MvpMatrix = gl.getUniformLocation(gl.program, 'u_MvpMatrix');
	var mvpMatrix = new Matrix4();

	gl.clearColor(0.0, 0.0, 0.0, 1.0);
	gl.enable(gl.DEPTH_TEST);
	
	//Set the position of vertices
	var num_cube = 1;
	var currentAngle = 0;

	var tick = function(){
		currentAngle = animate(currentAngle);
		initVertexSceneBuffers(gl, canvas, u_MvpMatrix, mvpMatrix);
		gl.clear(gl.COLOR_BUFFER_BIT);
		initVertexCubeBuffers(gl, canvas, currentAngle, u_MvpMatrix, mvpMatrix, num_cube);
		requestAnimationFrame(tick);
	}

	tick();
	
}

var ANGLE_STEP = 75.0;

function initVertexSceneBuffers(gl, canvas, u_MvpMatrix, mvpMatrix){
	
// Vertex coordinates and color
 var vertices = new Float32Array([
	 20.0, 20.0, -2.0,	  -20.0, 20.0, -2.0,	 -20.0, -20.0, -2.0, 	20.0, -20.0, -2.0,
  ]);	

 // Indices of the vertices
 var indices = new Uint8Array([
 	 0, 1, 2, 0, 2, 3, // front 0123 
  ]);

 //Color
 var colors = new Float32Array([
	 1.0, 1.0, 1.0, 	1.0, 0.0, 1.0, 		0.0, 1.0, 1.0, 		1.0, 1.0, 0.0 // Scene color
  ]);


 var indexBuffer = gl.createBuffer();

 if(!initArrayBuffer(gl, vertices, 3, gl.FLOAT, 'a_Position')){
 	console.log('Failed to initial array buffer');
 	return;
 }

 if(!initArrayBuffer(gl, colors, 3, gl.FLOAT, 'a_Color')){
 	console.log('Failed to initial array buffer');
 	return;
 }

 // Write the indices to the buffer object
 gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
 gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

 drawScene(gl, indices.length, canvas, 0, u_MvpMatrix, mvpMatrix);	

}

function initVertexCubeBuffers(gl, canvas, currentAngle, u_MvpMatrix, mvpMatrix, num_cube){
	
// Vertex coordinates and color
 var vertices = new Float32Array([
	 	1.0, 1.0, 1.0,		 -1.0, 1.0, 1.0,	-1.0, -1.0, 1.0, 	1.0, -1.0, 1.0,
	 	1.0, 1.0, 1.0,		 1.0, -1.0, 1.0,	1.0, -1.0, -1.0,	1.0, 1.0, -1.0,
	 	1.0, 1.0, 1.0,		 1.0, 1.0, -1.0,	-1.0, 1.0, -1.0,	-1.0, 1.0, 1.0,

	 	-1.0, 1.0, 1.0,		 -1.0, 1.0, -1.0, 	-1.0, -1.0, -1.0, 	-1.0, -1.0, 1.0,
	 	-1.0, -1.0, 1.0,	 -1.0, -1.0, -1.0, 	 1.0, -1.0, -1.0, 	 1.0, -1.0, 1.0,
	 	-1.0, 1.0, -1.0,	 1.0, 1.0, -1.0,	1.0, -1.0, -1.0,	-1.0, -1.0, -1.0
	 	
 	]);	

 // Indices of the vertices
 var indices = new Uint8Array([
	 0, 1, 2, 0, 2, 3, // front 0123 
	 4, 5, 6, 4, 6, 7, // right 0345 
	 8, 9, 10, 8, 10, 11,// u 0561	 	
	 12, 13, 14, 12, 14, 15, // left 1672 
	 16, 17, 18, 16, 18, 19,// down	2743
	 20, 21, 22, 20, 22, 23 // back	6547
 ]);

 //Color
 var colors = new Float32Array([

 	 1.0, 1.0, 1.0, 	1.0, 1.0, 1.0, 		1.0, 1.0, 1.0, 		1.0, 1.0, 1.0, // blk
 	 1.0, 0.0, 0.0,		1.0, 0.0, 0.0,  	1.0, 0.0, 0.0,  	1.0, 0.0, 0.0, // r
 	 0.0, 1.0, 1.0,  	0.0, 1.0, 1.0,  	0.0, 1.0, 1.0,  	0.0, 1.0, 1.0, // ..
 	 0.7, 0.5, 0.5,  	0.7, 0.5, 0.5,  	0.7, 0.5, 0.5,  	0.7, 0.5, 0.5, // w
	 1.0, 1.0, 0.5,  	1.0, 1.0, 0.5,  	1.0, 1.0, 0.5,  	1.0, 1.0, 0.5, // 
 	 0.5, 0.3, 0.4,  	0.5, 0.3, 0.4,  	0.5, 0.3, 0.4, 		0.5, 0.3, 0.4  // b
 
 	]);

 // Create a buffer object
 //var vertexBuffer = gl.createBuffer();
 var indexBuffer = gl.createBuffer();
 //var colorBuffer = gl.createBuffer();
 //var sceneBuffer = gl.createBuffer();

 if(!initArrayBuffer(gl, vertices, 3, gl.FLOAT, 'a_Position')){
 	console.log('Failed to initial array buffer');
 	return;
 }

 if(!initArrayBuffer(gl, colors, 3, gl.FLOAT, 'a_Color')){
 	console.log('Failed to initial array buffer');
 	return;
 }

 // Write the indices to the buffer object
 gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
 gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

 var n = indices.length;


 drawCube(gl, indices.length, canvas, currentAngle, u_MvpMatrix, mvpMatrix, num_cube);

}


var g_last = Date.now();
function animate(angle){
	var now = Date.now();
	var elapse = now - g_last;
	g_last = now;

	var newAngle = angle + (ANGLE_STEP * elapse) / 1000.0;
	return newAngle % 360;
};



function drawScene(gl, n, canvas, currentAngle, u_MvpMatrix, mvpMatrix){
	var modelMatrix = new Matrix4();
	var viewMatrix = new Matrix4();
	var projMatrix = new Matrix4();

	modelMatrix.setRotate(currentAngle, 1, -1, 0);
	viewMatrix.setLookAt(0, -60, 40, 0, 1.5, -2.0, 0, 1, 0)
	projMatrix.setPerspective(30, canvas.width/canvas.height, 1, 100);
	mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix);

	gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
	gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
};


var stack = [];
function mPush(mvpMatrix){
	
	var copy = new Matrix4();
	copy.set(mvpMatrix);
	stack.push(copy);


};

function mPop(mvpMatrix){


	mvpMatrix = stack.pop();
};


function drawCube(gl, n, canvas, currentAngle, u_MvpMatrix, mvpMatrix, num_cube, modelMatrix){
	
	var modelMatrix = new Matrix4();
	var viewMatrix = new Matrix4();
	var projMatrix = new Matrix4();	

	viewMatrix.setLookAt(0, -50, 0, 0, 1.5, -2.0, 0, 1, 0)
	projMatrix.setPerspective(30, canvas.width/canvas.height, 1, 100);
	// 
	// 	// cube 1
	modelMatrix.setIdentity();
	mvpMatrix.multiply(projMatrix).multiply(viewMatrix).multiply(modelMatrix);
	
	mPush(mvpMatrix);
	
	modelMatrix.setRotate(currentAngle, 1, -1, 0);
	mvpMatrix.multiply(modelMatrix);	


	gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);
	gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);

	mPop(mvpMatrix);


	// cube 2
	modelMatrix.translate(0, 10, 0);
	
	//mPush(mvpMatrix);
	
	modelMatrix.rotate(currentAngle, 1, -1, 0);
	mvpMatrix.set(projMatrix).multiply(viewMatrix).multiply(modelMatrix);

	gl.uniformMatrix4fv(u_MvpMatrix, false, mvpMatrix.elements);
	gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
	
	mPop(mvpMatrix);
};

function initArrayBuffer(gl, data, num, type, attribute){
	var buffer = gl.createBuffer();


	var a_attribute = gl.getAttribLocation(gl.program, attribute);	
	
	gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
	gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);  

	gl.vertexAttribPointer(a_attribute, num, type, false, 0, 0);
	gl.enableVertexAttribArray(a_attribute);

	return true;
};
